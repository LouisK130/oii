<!DOCTYPE _ [
<!ENTITY v1_adc_cols "trigger processingEndTime fluorescenceLow fluoresenceHigh scatteringLow scatteringHigh comparatorPulse triggerOpenTime frameGrabTime bottom left height width byteOffset valveStatus">
<!ENTITY v1_adc_types "int float float float float float float float float int int int int int double">
<!ENTITY v2_adc_cols "trigger processingEndTime pmtA pmtB pmtC pmtD peakA peakB peakC peakD timeOfFlight grabTimeStart frameGrabTime bottom left height width byteOffset comparatorOut startPoint signalStrength valveStatus">
<!ENTITY v2_adc_types "int float float float float float float float float float float float float int int int int int float int int int">
]>
<namespace name="ifcb">
  <!-- general regular expressions -->
  <rule name="re">
    <!-- identifier with no _ or . allowed (examples: "foo", "bar", "mp3") -->
    <var name="re.id">([a-zA-Z][a-zA-Z0-9]*)</var>
    <!-- extension (example ".jpg", ".mp3") matching everything but the period -->
    <var name="re.ext">(?:\.${re.id})</var>
    <!-- integer (zero-padding allowed) -->
    <var name="re.int">([0-9]+)</var>
  </rule>
  <!-- IFCB identifier parsing rule -->
  <rule name="pid" uses="pid">
    <!-- separate namespace part from rest of pid -->
    <match var="pid" pattern="(.*/)?(.*)" groups="namespace suffix"/>
    <!-- if there's a namespace, extract just the namespace's lid -->
    <!-- e.g., http://foo.bar.edu/baz/ has an lid of baz -->
    <match var="namespace" pattern="(?:.*/)?(.*)/$" groups="ns_lid" optional="true"/>
    <!-- first, parse ID to determine IFCB schema version and extract timestamp -->
    <first>
      <!-- IFCB v1 ID syntax -->
      <match var="suffix" timestamp="(IFCB1_(yyyy_YYY_HHMMSS))(any)" groups="lid timestamp tpe">
	<var name="schema_version">v1</var>
	<var name="adc_cols">&v1_adc_cols;</var>
	<var name="instrument">${n1}</var>
	<var name="year">${yyyy}</var>
	<var name="yearday">${yyyy}_${YYY}</var>
	<var name="timestamp_format">%Y_%j_%H%M%S</var>
      </match>
      <!-- IFCB v2 ID syntax -->
      <match var="suffix" timestamp="(D(yyyymmddTHHMMSS)_IFCB111)(any)" groups="lid timestamp tpe">
	<var name="schema_version">v2</var>
	<var name="adc_cols">&v2_adc_cols;</var>
	<var name="instrument">${n1}</var>
	<var name="year">${yyyy}</var>
	<var name="yearday">${yyyy}${dd}</var>
	<var name="timestamp_format">%Y%m%dT%H%M%S</var>
      </match>
    </first>
    <!-- now get any _target_product.extension -->
    <all include="target product extension">
      <invoke rule="ifcb.re"/>
      <var name="re.target">(?:_${re.int})</var>
      <var name="re.product">(?:_${re.id})</var>
      <!-- default product is raw -->
      <var name="product">raw</var>
      <match var="tpe" pattern="${re.target}?${re.product}?${re.ext}?"
	     groups="target product extension"/>
    </all>
  </rule>
  <namespace name="adc">
    <!-- return the column scheme for a given schema -->
    <rule name="schema" uses="schema_version">
      <first>
	<test var="schema_version" eq="v1">
	  <var name="columns">&v1_adc_cols;</var>
	  <var name="types">&v1_adc_types;</var>
	</test>
	<test var="schema_version" eq="v2">
	  <var name="columns">&v2_adc_cols;</var>
	  <var name="types">&v2_adc_types;</var>
	</test>
      </first>
    </rule>
    <!-- given an ADC file and a schema version, return all the targets as solutions -->
    <rule name="parse" uses="adc_file schema_version">
      <all count="targetNumber">
	<first>
	  <test var="schema_version" eq="v1">
	    <csv file="${adc_file}" vars="&v1_adc_cols;"/>
	  </test>
	  <test var="schema_version" eq="v2">
	    <csv file="${adc_file}" vars="&v2_adc_cols;"/>
	  </test>
	</first>
      </all>
    </rule>
    <!-- given an ADC file, schema version, and target number, return that target -->
    <rule name="get_target" uses="adc_file schema_version target">
      <invoke rule="ifcb.adc.parse" using="adc_file schema_version" nth="${target}" retain=" "/>
    </rule>
    <rule name="get_targets" uses="adc_file schema_version">
      <invoke rule="ifcb.adc.parse" using="adc_file schema_version" retain=" "/>
      <test var="height" gt="0"/>
      <test var="width" gt="0"/>
    </rule>
  </namespace>
  <namespace name="files">
    <!-- given a parsed pid including extension, and a root directory,
	 return all possible candidate paths -->
    <rule name="raw_path">
      <var name="filename">${lid}.${extension}</var>
      <!-- otherwise we're in a schema-dependent directory structure -->
      <first>
	<test var="schema_version" eq="v1">
	  <var name="raw_path">${root}/IFCB${instrument}_${yearday}/${filename}</var>
	</test>
	<test var="schema_version" eq="v2">
	  <var name="raw_path">${root}/D${year}/D${yearday}/${filename}</var>
	</test>
      </first>
      <!-- sometimes the directory structure is flat -->
      <var name="raw_path">${root}/${filename}</var>
    </rule>
    <rule name="find_raw_file" nth="1">
      <invoke rule="ifcb.files.raw_path"/>
      <path match="${raw_path}"/>
    </rule>
    <rule name="find_raw_fileset" include="hdr_path adc_path roi_path">
      <var name="extension">hdr</var>
      <invoke rule="ifcb.files.find_raw_file" rename="raw_path" as="hdr_path"/>
      <all>
	<var name="extension">
	  <val>adc</val>
	  <val>adc.mod</val>
	</var>
	<invoke rule="ifcb.files.find_raw_file" rename="raw_path" as="adc_path"/>
      </all>
      <var name="extension">roi</var>
      <invoke rule="ifcb.files.find_raw_file" rename="raw_path" as="roi_path"/>
    </rule>
    <rule name="list_raw_filesets" uses="root">
      <!-- strategy: list hdr files, then look for corresponding adc and roi files -->
      <any>
	<var name="data_dir">${root}</var>
	<path var="data_dir" match="${root}/IFCB*"/>
	<path var="year_dir" match="${root}/D*">
	  <path var="data_dir" match="${year_dir}/D*"/>
	</path>
      </any>
      <path var="hdr_path" match="${data_dir}/*.hdr"/>
      <match var="hdr_path" pattern="(.*/(.*))\.hdr$" groups="basename lid"/>
      <!-- look for other files in the same dir -->
      <path var="roi_path" match="${basename}.roi"/>
      <any>
	<path var="adc_path" match="${basename}.adc"/>
	<!-- FIXME needs to also work with .adc.mod files -->
      </any>
    </rule>
  </namespace>
</namespace>
